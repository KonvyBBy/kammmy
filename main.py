import discord
from discord.ext import commands, tasks
from discord import app_commands
import json
import os
from datetime import datetime, timedelta
from dotenv import load_dotenv
from typing import Optional, List, Union
import aiohttp
import asyncio

load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')

CONFIG = {
    "VOUCHES_CHANNEL_ID": 1462381972474167491,
    "ALERTS_CHANNEL_ID": 1462664758758084821, 
    "BUYER_ROLE_NAME": "Customer",
    "AUTHORIZED_USER_IDS": [1301929836696309845, 919629905052979290],
    "EMBED_COLOR": 0xFFA500,
    "FOOTER_TEXT": "Generated By | Hidden Services",
    "GIF_URL":
    "https://media.discordapp.net/attachments/1285365363839860816/1302084297431191552/Comp_1_1.gif?ex=696edc80&is=696d8b00&hm=500360a99081da50bdf99814ad0ce62f0ab0cabf83995f2e1efa85f490332e1b&=",
    "EMOJIS": {
        "key": "¬ª",
        "duration": "¬ª",
        "vouch": "¬ª",
        "user": "¬ª",
        "stock": "¬ª",
        "history": "¬ª",
        "check": "‚úÖ",
        "cross": "‚ùå"
    },
    "PRODUCTS": ["Fortnite Private", "Fortnite Public", "Perm Spoofer"],
    "DURATIONS": ["1 Day", "7 Days", "30 Days", "Lifetime"],
    "LOW_STOCK_THRESHOLD": 5,
    "WEBHOOK_URL": "https://discord.com/api/webhooks/1469144387286994985/Ahnt6H00KMwkIa9cIrdGmALtm8gCt3NgIHE0i7VQ1fPY8-ioItSV7tfxLnVUh6PDn_6Y",
    "TICKET_CATEGORY_NAME": "Support Tickets"
}

DB_FILE = "keys_database.json"


def load_db():
    if os.path.exists(DB_FILE):
        with open(DB_FILE, 'r') as f:
            try:
                data = json.load(f)
                if "stock" not in data: data["stock"] = {}
                if not isinstance(data["stock"], dict):
                    data["stock"] = {}
                if "sent_keys" not in data: data["sent_keys"] = []
                if "reminders" not in data: data["reminders"] = []
                if "tickets" not in data: data["tickets"] = {}
                return data
            except json.JSONDecodeError:
                pass
    return {"stock": {}, "sent_keys": [], "reminders": [], "tickets": {}}


def save_db(data):
    with open(DB_FILE, 'w') as f:
        json.dump(data, f, indent=4)


async def log_to_webhook(title: str, description: str, color: int = 0x00ff00, fields: List[dict] = None):
    """Send log message to webhook"""
    try:
        async with aiohttp.ClientSession() as session:
            embed = {
                "title": title,
                "description": description,
                "color": color,
                "timestamp": datetime.utcnow().isoformat(),
                "footer": {"text": "Bot Logging System"}
            }
            if fields:
                embed["fields"] = fields
            
            webhook_data = {"embeds": [embed]}
            await session.post(CONFIG["WEBHOOK_URL"], json=webhook_data)
    except Exception as e:
        print(f"Failed to log to webhook: {e}")


db = load_db()


class TicketButton(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
    
    @discord.ui.button(label="Open Ticket", style=discord.ButtonStyle.green, custom_id="open_ticket", emoji="üé´")
    async def open_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        # Check if user already has an open ticket
        user_tickets = [t for t in db.get("tickets", {}).values() if t.get("user_id") == interaction.user.id and t.get("status") == "open"]
        if user_tickets:
            await interaction.response.send_message(f"{CONFIG['EMOJIS']['cross']} You already have an open ticket!", ephemeral=True)
            return
        
        await interaction.response.defer(ephemeral=True)
        
        # Get or create ticket category
        guild = interaction.guild
        category = discord.utils.get(guild.categories, name=CONFIG["TICKET_CATEGORY_NAME"])
        if not category:
            category = await guild.create_category(CONFIG["TICKET_CATEGORY_NAME"])
        
        # Create ticket channel
        ticket_num = len(db.get("tickets", {})) + 1
        channel_name = f"ticket-{ticket_num}-{interaction.user.name}"
        
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(read_messages=False),
            interaction.user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
            guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
        }
        
        ticket_channel = await guild.create_text_channel(
            name=channel_name,
            category=category,
            overwrites=overwrites
        )
        
        # Save ticket to database
        db["tickets"][str(ticket_channel.id)] = {
            "ticket_num": ticket_num,
            "user_id": interaction.user.id,
            "channel_id": ticket_channel.id,
            "status": "open",
            "created_at": datetime.utcnow().isoformat()
        }
        save_db(db)
        
        # Send ticket message
        embed = discord.Embed(
            title=f"üé´ Support Ticket #{ticket_num}",
            description=f"Welcome {interaction.user.mention}! Support staff will be with you shortly.\n\nPlease describe your issue in detail.",
            color=CONFIG["EMBED_COLOR"]
        )
        embed.set_footer(text=CONFIG["FOOTER_TEXT"])
        
        close_view = CloseTicketButton()
        await ticket_channel.send(embed=embed, view=close_view)
        
        await interaction.followup.send(f"{CONFIG['EMOJIS']['check']} Ticket created: {ticket_channel.mention}", ephemeral=True)
        
        # Log to webhook
        await log_to_webhook(
            title="üé´ Ticket Opened",
            description=f"Ticket #{ticket_num} created",
            color=0x00ff00,
            fields=[
                {"name": "User", "value": f"{interaction.user.mention} ({interaction.user.id})", "inline": True},
                {"name": "Channel", "value": ticket_channel.mention, "inline": True}
            ]
        )


class CloseTicketButton(discord.ui.View):
    def __init__(self):
        super().__init__(timeout=None)
    
    @discord.ui.button(label="Close Ticket", style=discord.ButtonStyle.red, custom_id="close_ticket", emoji="üîí")
    async def close_ticket(self, interaction: discord.Interaction, button: discord.ui.Button):
        channel_id = str(interaction.channel.id)
        if channel_id not in db.get("tickets", {}):
            await interaction.response.send_message(f"{CONFIG['EMOJIS']['cross']} This is not a valid ticket!", ephemeral=True)
            return
        
        ticket_data = db["tickets"][channel_id]
        ticket_data["status"] = "closed"
        ticket_data["closed_at"] = datetime.utcnow().isoformat()
        ticket_data["closed_by"] = interaction.user.id
        save_db(db)
        
        await interaction.response.send_message(f"{CONFIG['EMOJIS']['check']} Ticket closing in 5 seconds...")
        
        # Log to webhook
        await log_to_webhook(
            title="üîí Ticket Closed",
            description=f"Ticket #{ticket_data['ticket_num']} closed",
            color=0xff0000,
            fields=[
                {"name": "Closed By", "value": f"{interaction.user.mention} ({interaction.user.id})", "inline": True},
                {"name": "Original User", "value": f"<@{ticket_data['user_id']}>", "inline": True}
            ]
        )
        
        await asyncio.sleep(5)
        await interaction.channel.delete()


class MyBot(commands.Bot):

    def __init__(self):
        intents = discord.Intents.default()
        intents.members = True
        intents.message_content = True
        super().__init__(command_prefix="!", intents=intents)

    async def setup_hook(self):
        # Register persistent views
        self.add_view(TicketButton())
        self.add_view(CloseTicketButton())
        self.vouch_reminder_task.start()
        await self.tree.sync()
        print(f'‚úÖ Bot is online as {self.user}')

    @tasks.loop(minutes=30)
    async def vouch_reminder_task(self):
        now = datetime.utcnow()
        to_remove = []
        for reminder in db.get("reminders", []):
            remind_time = datetime.fromisoformat(reminder["time"])
            if now >= remind_time:
                user = self.get_user(reminder["user_id"])
                if user:
                    try:
                        embed = discord.Embed(
                            title="Feedback Request",
                            description=
                            "Hey! Hope you're enjoying your purchase. If you have a moment, we'd appreciate a vouch in our channel!",
                            color=CONFIG["EMBED_COLOR"])
                        embed.set_footer(text=CONFIG["FOOTER_TEXT"])
                        await user.send(embed=embed)
                    except:
                        pass
                to_remove.append(reminder)

        if to_remove:
            db["reminders"] = [
                r for r in db["reminders"] if r not in to_remove
            ]
            save_db(db)


bot = MyBot()

def is_authorized():

    async def predicate(interaction: discord.Interaction):
        if await bot.is_owner(interaction.user):
            return True
        return interaction.user.id in CONFIG["AUTHORIZED_USER_IDS"]

    return app_commands.check(predicate)


def create_styled_embed(title: str,
                        description: str,
                        image_url: Optional[str] = None):
    embed = discord.Embed(title=title,
                          description=description,
                          color=CONFIG["EMBED_COLOR"])
    if image_url:
        embed.set_image(url=image_url)
    embed.set_footer(text=CONFIG["FOOTER_TEXT"])
    return embed


@bot.tree.command(name="review", description="Submit a review for our service")
@app_commands.describe(rating="Rate from 1-5 stars", review="Your review text")
@app_commands.choices(rating=[
    app_commands.Choice(name="‚≠ê 1 Star", value=1),
    app_commands.Choice(name="‚≠ê‚≠ê 2 Stars", value=2),
    app_commands.Choice(name="‚≠ê‚≠ê‚≠ê 3 Stars", value=3),
    app_commands.Choice(name="‚≠ê‚≠ê‚≠ê‚≠ê 4 Stars", value=4),
    app_commands.Choice(name="‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê 5 Stars", value=5)
])
async def review(interaction: discord.Interaction, rating: int, review: str):
    await interaction.response.defer(ephemeral=True)
    
    # Create review embed
    stars = "‚≠ê" * rating
    embed = discord.Embed(
        title=f"‚≠ê New Review - {stars}",
        description=review,
        color=CONFIG["EMBED_COLOR"],
        timestamp=datetime.utcnow()
    )
    embed.set_author(name=interaction.user.name, icon_url=interaction.user.display_avatar.url)
    embed.add_field(name="Rating", value=f"{rating}/5 {stars}", inline=True)
    embed.add_field(name="User", value=interaction.user.mention, inline=True)
    embed.set_footer(text=CONFIG["FOOTER_TEXT"])
    embed.set_thumbnail(url=CONFIG["GIF_URL"])
    
    # Send to vouches channel
    vouches_channel = bot.get_channel(CONFIG["VOUCHES_CHANNEL_ID"])
    if vouches_channel:
        await vouches_channel.send(embed=embed)
    
    # Log to webhook
    await log_to_webhook(
        title="‚≠ê New Review Submitted",
        description=f"Rating: {rating}/5\nReview: {review[:100]}...",
        color=0xFFD700,
        fields=[
            {"name": "User", "value": f"{interaction.user.mention} ({interaction.user.id})", "inline": True},
            {"name": "Rating", "value": f"{rating}/5 {stars}", "inline": True}
        ]
    )
    
    await interaction.followup.send(
        f"{CONFIG['EMOJIS']['check']} Thank you for your review! It has been submitted.",
        ephemeral=True
    )


@bot.tree.command(name="ticketpanel", description="Create a ticket panel for users to open support tickets")
@is_authorized()
async def ticketpanel(interaction: discord.Interaction):
    embed = discord.Embed(
        title="üé´ Support Ticket System",
        description="Need help? Click the button below to open a support ticket!\n\nOur staff will assist you as soon as possible.",
        color=CONFIG["EMBED_COLOR"]
    )
    embed.set_footer(text=CONFIG["FOOTER_TEXT"])
    embed.set_thumbnail(url=CONFIG["GIF_URL"])
    
    view = TicketButton()
    await interaction.channel.send(embed=embed, view=view)
    await interaction.response.send_message(f"{CONFIG['EMOJIS']['check']} Ticket panel created!", ephemeral=True)
    
    # Log to webhook
    await log_to_webhook(
        title="üé´ Ticket Panel Created",
        description="New ticket panel deployed",
        color=0x0099ff,
        fields=[
            {"name": "Created By", "value": f"{interaction.user.mention} ({interaction.user.id})", "inline": True},
            {"name": "Channel", "value": interaction.channel.mention, "inline": True}
        ]
    )


@bot.tree.command(name="stock", description="Load keys into inventory")
@app_commands.describe(product="Select product",
                       duration="Select duration",
                       keys="Paste keys separated by commas",
                       file="Attach a .txt file")
@app_commands.choices(
    product=[app_commands.Choice(name=p, value=p) for p in CONFIG["PRODUCTS"]],
    duration=[
        app_commands.Choice(name=d, value=d) for d in CONFIG["DURATIONS"]
    ])
@is_authorized()
async def stock(interaction: discord.Interaction,
                product: str,
                duration: str,
                keys: Optional[str] = None,
                file: Optional[discord.Attachment] = None):
    await interaction.response.defer(ephemeral=True)
    key_list = []
    if file and file.filename.endswith('.txt'):
        content = await file.read()
        key_list = [
            k.strip() for k in content.decode('utf-8').split('\n')
            if k.strip()
        ]
    elif keys:
        key_list = [k.strip() for k in keys.split(',') if k.strip()]
    else:
        await interaction.followup.send(
            f"{CONFIG['EMOJIS']['cross']} Please provide keys or attach a .txt file!",
            ephemeral=True)
        return

    existing_in_stock = []
    if isinstance(db.get("stock"), dict):
        for prod_data in db["stock"].values():
            if isinstance(prod_data, dict):
                for dur_keys in prod_data.values():
                    if isinstance(dur_keys, list):
                        existing_in_stock.extend(dur_keys)

    existing_sent = [entry["key"] for entry in db.get("sent_keys", [])]
    all_existing = set(existing_in_stock + existing_sent)

    new_keys = [k for k in key_list if k not in all_existing]
    duplicates = len(key_list) - len(new_keys)

    if not new_keys:
        await interaction.followup.send(
            f"{CONFIG['EMOJIS']['cross']} No new keys added. ({duplicates} duplicates)",
            ephemeral=True)
        return

    if product not in db["stock"]: db["stock"][product] = {}
    if not isinstance(db["stock"][product], dict): db["stock"][product] = {}
    if duration not in db["stock"][product]:
        db["stock"][product][duration] = []
    if not isinstance(db["stock"][product][duration], list):
        db["stock"][product][duration] = []

    db["stock"][product][duration].extend(new_keys)
    save_db(db)

    desc = (f"**Product {CONFIG['EMOJIS']['key']}** {product}\n"
            f"**Duration {CONFIG['EMOJIS']['duration']}** {duration}\n"
            f"**Added {CONFIG['EMOJIS']['check']}** {len(new_keys)}\n"
            f"**Duplicates {CONFIG['EMOJIS']['cross']}** {duplicates}")
    embed = create_styled_embed(
        f"{CONFIG['EMOJIS']['check']} Keys Stocked Successfully", desc)
    await interaction.followup.send(embed=embed, ephemeral=True)
    
    # Log to webhook
    await log_to_webhook(
        title="üì¶ Keys Stocked",
        description=f"Added {len(new_keys)} new keys",
        color=0x00ff00,
        fields=[
            {"name": "Product", "value": product, "inline": True},
            {"name": "Duration", "value": duration, "inline": True},
            {"name": "Keys Added", "value": str(len(new_keys)), "inline": True},
            {"name": "Duplicates", "value": str(duplicates), "inline": True},
            {"name": "Added By", "value": f"{interaction.user.mention} ({interaction.user.id})", "inline": False}
        ]
    )


@bot.tree.command(name="inventory", description="View current key stock")
@is_authorized()
async def inventory(interaction: discord.Interaction):
    if not db["stock"]:
        desc = "No keys in stock!"
    else:
        fields = []
        for product, durations in db["stock"].items():
            if not isinstance(durations, dict): continue
            total = sum(
                len(keys) for keys in durations.values()
                if isinstance(keys, list))
            info = "\n".join([
                f"‚Ä¢ {dur}: {len(keys)}" for dur, keys in durations.items()
                if isinstance(keys, list) and keys
            ])
            fields.append(
                f"**{CONFIG['EMOJIS']['stock']} {product} ({total})**\n{info or 'Out of stock'}"
            )
        desc = "\n\n".join(fields)

    embed = create_styled_embed(f"{CONFIG['EMOJIS']['stock']} Key Inventory",
                                desc)
    await interaction.response.send_message(embed=embed, ephemeral=True)
    
    # Log to webhook
    await log_to_webhook(
        title="üìä Inventory Checked",
        description="Inventory accessed",
        color=0x0099ff,
        fields=[
            {"name": "Checked By", "value": f"{interaction.user.mention} ({interaction.user.id})", "inline": True}
        ]
    )


@bot.tree.command(name="send", description="Send a key to a user")
@app_commands.describe(product="Select product",
                       user="User to send the key to",
                       duration="Select duration")
@app_commands.choices(
    product=[app_commands.Choice(name=p, value=p) for p in CONFIG["PRODUCTS"]],
    duration=[
        app_commands.Choice(name=d, value=d) for d in CONFIG["DURATIONS"]
    ])
@is_authorized()
async def send(interaction: discord.Interaction, product: str,
               user: discord.Member, duration: str):
    await interaction.response.defer()

    if product not in db["stock"] or not isinstance(
            db["stock"][product],
            dict) or duration not in db["stock"][product] or not isinstance(
                db["stock"][product][duration],
                list) or not db["stock"][product][duration]:
        await interaction.followup.send(
            f"{CONFIG['EMOJIS']['cross']} No keys available for **{product}** ({duration})!",
            ephemeral=True)
        return

    key = db["stock"][product][duration].pop(0)
    db["sent_keys"].append({
        "product": product,
        "key": key,
        "user_id": user.id,
        "duration": duration,
        "timestamp": datetime.utcnow().isoformat(),
        "sent_by": interaction.user.id
    })

    db["reminders"].append({
        "user_id":
        user.id,
        "time": (datetime.utcnow() + timedelta(hours=24)).isoformat()
    })
    save_db(db)

    vouch_link = "none"
    if interaction.guild:
        vouch_link = f"[Click Here](https://discord.com/channels/{interaction.guild.id}/{CONFIG['VOUCHES_CHANNEL_ID']})"

    dm_desc = (f"**Key {CONFIG['EMOJIS']['key']}**\n"
               f"```\n{key}\n```\n"
               f"**Product {CONFIG['EMOJIS']['key']}** {product}\n"
               f"**Duration {CONFIG['EMOJIS']['duration']}** {duration}\n"
               f"**Vouch {CONFIG['EMOJIS']['vouch']}** {vouch_link}\n"
               f"**User {CONFIG['EMOJIS']['user']}** {user.mention}")
    dm_embed = create_styled_embed("Hidden Services | Key Generated",
                                   dm_desc,
                                   image_url=CONFIG["GIF_URL"])

    try:
        await user.send(embed=dm_embed)
        dm_status = f"{CONFIG['EMOJIS']['check']}"
    except:
        dm_status = f"{CONFIG['EMOJIS']['cross']} (DMs closed)"

    if interaction.guild:
        buyer_role = discord.utils.get(interaction.guild.roles,
                                       name=CONFIG["BUYER_ROLE_NAME"])
        if buyer_role:
            try:
                await user.add_roles(buyer_role)
            except:
                pass

    total_stock = sum(
        len(keys) for keys in db["stock"][product].values()
        if isinstance(keys, list))
    if total_stock <= CONFIG["LOW_STOCK_THRESHOLD"]:
        alerts_chan = bot.get_channel(CONFIG["ALERTS_CHANNEL_ID"])
        if isinstance(alerts_chan, discord.abc.Messageable):
            await alerts_chan.send(
                f"‚ö†Ô∏è **Low Stock Alert!** {product} only has {total_stock} keys left!"
            )

    confirm_desc = (f"**Success {CONFIG['EMOJIS']['check']}**\n"
                    f"**User {CONFIG['EMOJIS']['user']}** {user.mention}\n"
                    f"**Product {CONFIG['EMOJIS']['key']}** {product}\n"
                    f"**Duration {CONFIG['EMOJIS']['duration']}** {duration}\n"
                    f"**DM Status** {dm_status}")
    confirm_embed = create_styled_embed(
        "Hidden Services | Key Successfully Sent", confirm_desc)
    await interaction.followup.send(embed=confirm_embed)
    
    # Log to webhook
    await log_to_webhook(
        title="üîë Key Sent",
        description=f"Key delivered to user",
        color=0x00ff00,
        fields=[
            {"name": "Product", "value": product, "inline": True},
            {"name": "Duration", "value": duration, "inline": True},
            {"name": "Recipient", "value": f"{user.mention} ({user.id})", "inline": True},
            {"name": "Sent By", "value": f"{interaction.user.mention} ({interaction.user.id})", "inline": True},
            {"name": "DM Status", "value": dm_status, "inline": True},
            {"name": "Remaining Stock", "value": str(total_stock), "inline": True}
        ]
    )


@bot.tree.command(name="clearstock",
                  description="Clear all keys of a specific duration")
@app_commands.describe(product="Select product", duration="Select duration")
@app_commands.choices(
    product=[app_commands.Choice(name=p, value=p) for p in CONFIG["PRODUCTS"]],
    duration=[
        app_commands.Choice(name=d, value=d) for d in CONFIG["DURATIONS"]
    ])
@is_authorized()
async def clearstock(interaction: discord.Interaction, product: str,
                     duration: str):
    if product in db["stock"] and isinstance(
            db["stock"][product], dict) and duration in db["stock"][product]:
        count = len(db["stock"][product][duration])
        db["stock"][product][duration] = []
        save_db(db)
        desc = f"Cleared **{count}** keys from **{product}** ({duration})"
        embed = create_styled_embed(
            f"{CONFIG['EMOJIS']['check']} Stock Cleared", desc)
        await interaction.response.send_message(embed=embed, ephemeral=True)
        
        # Log to webhook
        await log_to_webhook(
            title="üóëÔ∏è Stock Cleared",
            description=f"Cleared {count} keys",
            color=0xff0000,
            fields=[
                {"name": "Product", "value": product, "inline": True},
                {"name": "Duration", "value": duration, "inline": True},
                {"name": "Keys Cleared", "value": str(count), "inline": True},
                {"name": "Cleared By", "value": f"{interaction.user.mention} ({interaction.user.id})", "inline": False}
            ]
        )
    else:
        await interaction.response.send_message(
            f"{CONFIG['EMOJIS']['cross']} No keys found for **{product}** ({duration})",
            ephemeral=True)


@bot.tree.command(name="logs", description="View recent key delivery logs")
@is_authorized()
async def logs(interaction: discord.Interaction):
    recent = db["sent_keys"][-10:]
    if not recent:
        await interaction.response.send_message("No logs found.",
                                                ephemeral=True)
        return

    log_list = []
    for log in reversed(recent):
        log_list.append(
            f"‚Ä¢ {log['product']} ({log['duration']}) -> <@{log['user_id']}> by <@{log['sent_by']}>"
        )
    desc = "\n".join(log_list)

    embed = create_styled_embed(
        f"{CONFIG['EMOJIS']['history']} Recent Delivery Logs", desc)
    await interaction.response.send_message(embed=embed, ephemeral=True)
    
    # Log to webhook
    await log_to_webhook(
        title="üìã Logs Accessed",
        description="Recent delivery logs viewed",
        color=0x0099ff,
        fields=[
            {"name": "Accessed By", "value": f"{interaction.user.mention} ({interaction.user.id})", "inline": True}
        ]
    )


@bot.tree.command(name="userhistory",
                  description="Check key history for a specific user")
@app_commands.describe(user="User to check")
@is_authorized()
async def userhistory(interaction: discord.Interaction, user: discord.User):
    history = [log for log in db["sent_keys"] if log["user_id"] == user.id]
    if not history:
        await interaction.response.send_message(
            f"No history for {user.mention}.", ephemeral=True)
        return

    hist_list = [
        f"‚Ä¢ {h['product']} ({h['duration']}) on {h['timestamp'][:10]}"
        for h in history[-15:]
    ]
    desc = "\n".join(hist_list)
    embed = create_styled_embed(
        f"{CONFIG['EMOJIS']['user']} History for {user.name}", desc)
    await interaction.response.send_message(embed=embed, ephemeral=True)
    
    # Log to webhook
    await log_to_webhook(
        title="üë§ User History Accessed",
        description=f"History checked for user",
        color=0x0099ff,
        fields=[
            {"name": "Target User", "value": f"{user.mention} ({user.id})", "inline": True},
            {"name": "Total Keys", "value": str(len(history)), "inline": True},
            {"name": "Accessed By", "value": f"{interaction.user.mention} ({interaction.user.id})", "inline": False}
        ]
    )


@bot.event
async def on_app_command_error(interaction: discord.Interaction,
                               error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CheckFailure):
        if not interaction.response.is_done():
            user_id = interaction.user.id
            await interaction.response.send_message(
                f"{CONFIG['EMOJIS']['cross']} **Authorization Failed!**\nYour ID: `{user_id}` is not in the authorized list.",
                ephemeral=True)
    else:
        print(f"Error in command: {error}")


if __name__ == "__main__":
    if TOKEN: bot.run(TOKEN)
