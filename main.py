import discord
from discord.ext import commands, tasks
from discord import app_commands
import json
import os
from datetime import datetime, timedelta
from dotenv import load_dotenv
from typing import Optional, List, Union

load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')

CONFIG = {
    "VOUCHES_CHANNEL_ID": 1462381972474167491,
    "ALERTS_CHANNEL_ID": 1462664758758084821, 
    "BUYER_ROLE_NAME": "Customer",
    "AUTHORIZED_USER_IDS": [1301929836696309845, 919629905052979290],
    "EMBED_COLOR": 0xFFA500,
    "FOOTER_TEXT": "Generated By | Hidden Services",
    "GIF_URL":
    "https://media.discordapp.net/attachments/1285365363839860816/1302084297431191552/Comp_1_1.gif?ex=696edc80&is=696d8b00&hm=500360a99081da50bdf99814ad0ce62f0ab0cabf83995f2e1efa85f490332e1b&=",
    "EMOJIS": {
        "key": "»",
        "duration": "»",
        "vouch": "»",
        "user": "»",
        "stock": "»",
        "history": "»",
        "check": "✅",
        "cross": "❌"
    },
    "PRODUCTS": ["Fortnite Private", "Fortnite Public", "Perm Spoofer"],
    "DURATIONS": ["1 Day", "7 Days", "30 Days", "Lifetime"],
    "LOW_STOCK_THRESHOLD": 5
}

DB_FILE = "keys_database.json"


def load_db():
    if os.path.exists(DB_FILE):
        with open(DB_FILE, 'r') as f:
            try:
                data = json.load(f)
                if "stock" not in data: data["stock"] = {}
                if not isinstance(data["stock"], dict):
                    data["stock"] = {}
                if "sent_keys" not in data: data["sent_keys"] = []
                if "reminders" not in data: data["reminders"] = []
                return data
            except json.JSONDecodeError:
                pass
    return {"stock": {}, "sent_keys": [], "reminders": []}


def save_db(data):
    with open(DB_FILE, 'w') as f:
        json.dump(data, f, indent=4)


db = load_db()


class MyBot(commands.Bot):

    def __init__(self):
        intents = discord.Intents.default()
        intents.members = True
        intents.message_content = True
        super().__init__(command_prefix="!", intents=intents)

    async def setup_hook(self):
        self.vouch_reminder_task.start()
        await self.tree.sync()
        print(f'✅ Bot is online as {self.user}')

    @tasks.loop(minutes=30)
    async def vouch_reminder_task(self):
        now = datetime.utcnow()
        to_remove = []
        for reminder in db.get("reminders", []):
            remind_time = datetime.fromisoformat(reminder["time"])
            if now >= remind_time:
                user = self.get_user(reminder["user_id"])
                if user:
                    try:
                        embed = discord.Embed(
                            title="Feedback Request",
                            description=
                            "Hey! Hope you're enjoying your purchase. If you have a moment, we'd appreciate a vouch in our channel!",
                            color=CONFIG["EMBED_COLOR"])
                        embed.set_footer(text=CONFIG["FOOTER_TEXT"])
                        await user.send(embed=embed)
                    except:
                        pass
                to_remove.append(reminder)

        if to_remove:
            db["reminders"] = [
                r for r in db["reminders"] if r not in to_remove
            ]
            save_db(db)


bot = MyBot()

def is_authorized():

    async def predicate(interaction: discord.Interaction):
        if await bot.is_owner(interaction.user):
            return True
        return interaction.user.id in CONFIG["AUTHORIZED_USER_IDS"]

    return app_commands.check(predicate)


def create_styled_embed(title: str,
                        description: str,
                        image_url: Optional[str] = None):
    embed = discord.Embed(title=title,
                          description=description,
                          color=CONFIG["EMBED_COLOR"])
    if image_url:
        embed.set_image(url=image_url)
    embed.set_footer(text=CONFIG["FOOTER_TEXT"])
    return embed


@bot.tree.command(name="stock", description="Load keys into inventory")
@app_commands.describe(product="Select product",
                       duration="Select duration",
                       keys="Paste keys separated by commas",
                       file="Attach a .txt file")
@app_commands.choices(
    product=[app_commands.Choice(name=p, value=p) for p in CONFIG["PRODUCTS"]],
    duration=[
        app_commands.Choice(name=d, value=d) for d in CONFIG["DURATIONS"]
    ])
@is_authorized()
async def stock(interaction: discord.Interaction,
                product: str,
                duration: str,
                keys: Optional[str] = None,
                file: Optional[discord.Attachment] = None):
    await interaction.response.defer(ephemeral=True)
    key_list = []
    if file and file.filename.endswith('.txt'):
        content = await file.read()
        key_list = [
            k.strip() for k in content.decode('utf-8').split('\n')
            if k.strip()
        ]
    elif keys:
        key_list = [k.strip() for k in keys.split(',') if k.strip()]
    else:
        await interaction.followup.send(
            f"{CONFIG['EMOJIS']['cross']} Please provide keys or attach a .txt file!",
            ephemeral=True)
        return

    existing_in_stock = []
    if isinstance(db.get("stock"), dict):
        for prod_data in db["stock"].values():
            if isinstance(prod_data, dict):
                for dur_keys in prod_data.values():
                    if isinstance(dur_keys, list):
                        existing_in_stock.extend(dur_keys)

    existing_sent = [entry["key"] for entry in db.get("sent_keys", [])]
    all_existing = set(existing_in_stock + existing_sent)

    new_keys = [k for k in key_list if k not in all_existing]
    duplicates = len(key_list) - len(new_keys)

    if not new_keys:
        await interaction.followup.send(
            f"{CONFIG['EMOJIS']['cross']} No new keys added. ({duplicates} duplicates)",
            ephemeral=True)
        return

    if product not in db["stock"]: db["stock"][product] = {}
    if not isinstance(db["stock"][product], dict): db["stock"][product] = {}
    if duration not in db["stock"][product]:
        db["stock"][product][duration] = []
    if not isinstance(db["stock"][product][duration], list):
        db["stock"][product][duration] = []

    db["stock"][product][duration].extend(new_keys)
    save_db(db)

    desc = (f"**Product {CONFIG['EMOJIS']['key']}** {product}\n"
            f"**Duration {CONFIG['EMOJIS']['duration']}** {duration}\n"
            f"**Added {CONFIG['EMOJIS']['check']}** {len(new_keys)}\n"
            f"**Duplicates {CONFIG['EMOJIS']['cross']}** {duplicates}")
    embed = create_styled_embed(
        f"{CONFIG['EMOJIS']['check']} Keys Stocked Successfully", desc)
    await interaction.followup.send(embed=embed, ephemeral=True)


@bot.tree.command(name="inventory", description="View current key stock")
@is_authorized()
async def inventory(interaction: discord.Interaction):
    if not db["stock"]:
        desc = "No keys in stock!"
    else:
        fields = []
        for product, durations in db["stock"].items():
            if not isinstance(durations, dict): continue
            total = sum(
                len(keys) for keys in durations.values()
                if isinstance(keys, list))
            info = "\n".join([
                f"• {dur}: {len(keys)}" for dur, keys in durations.items()
                if isinstance(keys, list) and keys
            ])
            fields.append(
                f"**{CONFIG['EMOJIS']['stock']} {product} ({total})**\n{info or 'Out of stock'}"
            )
        desc = "\n\n".join(fields)

    embed = create_styled_embed(f"{CONFIG['EMOJIS']['stock']} Key Inventory",
                                desc)
    await interaction.response.send_message(embed=embed, ephemeral=True)


@bot.tree.command(name="send", description="Send a key to a user")
@app_commands.describe(product="Select product",
                       user="User to send the key to",
                       duration="Select duration")
@app_commands.choices(
    product=[app_commands.Choice(name=p, value=p) for p in CONFIG["PRODUCTS"]],
    duration=[
        app_commands.Choice(name=d, value=d) for d in CONFIG["DURATIONS"]
    ])
@is_authorized()
async def send(interaction: discord.Interaction, product: str,
               user: discord.Member, duration: str):
    await interaction.response.defer()

    if product not in db["stock"] or not isinstance(
            db["stock"][product],
            dict) or duration not in db["stock"][product] or not isinstance(
                db["stock"][product][duration],
                list) or not db["stock"][product][duration]:
        await interaction.followup.send(
            f"{CONFIG['EMOJIS']['cross']} No keys available for **{product}** ({duration})!",
            ephemeral=True)
        return

    key = db["stock"][product][duration].pop(0)
    db["sent_keys"].append({
        "product": product,
        "key": key,
        "user_id": user.id,
        "duration": duration,
        "timestamp": datetime.utcnow().isoformat(),
        "sent_by": interaction.user.id
    })

    db["reminders"].append({
        "user_id":
        user.id,
        "time": (datetime.utcnow() + timedelta(hours=24)).isoformat()
    })
    save_db(db)

    vouch_link = "none"
    if interaction.guild:
        vouch_link = f"[Click Here](https://discord.com/channels/{interaction.guild.id}/{CONFIG['VOUCHES_CHANNEL_ID']})"

    dm_desc = (f"**Key {CONFIG['EMOJIS']['key']}**\n"
               f"```\n{key}\n```\n"
               f"**Product {CONFIG['EMOJIS']['key']}** {product}\n"
               f"**Duration {CONFIG['EMOJIS']['duration']}** {duration}\n"
               f"**Vouch {CONFIG['EMOJIS']['vouch']}** {vouch_link}\n"
               f"**User {CONFIG['EMOJIS']['user']}** {user.mention}")
    dm_embed = create_styled_embed("Hidden Services | Key Generated",
                                   dm_desc,
                                   image_url=CONFIG["GIF_URL"])

    try:
        await user.send(embed=dm_embed)
        dm_status = f"{CONFIG['EMOJIS']['check']}"
    except:
        dm_status = f"{CONFIG['EMOJIS']['cross']} (DMs closed)"

    if interaction.guild:
        buyer_role = discord.utils.get(interaction.guild.roles,
                                       name=CONFIG["BUYER_ROLE_NAME"])
        if buyer_role:
            try:
                await user.add_roles(buyer_role)
            except:
                pass

    total_stock = sum(
        len(keys) for keys in db["stock"][product].values()
        if isinstance(keys, list))
    if total_stock <= CONFIG["LOW_STOCK_THRESHOLD"]:
        alerts_chan = bot.get_channel(CONFIG["ALERTS_CHANNEL_ID"])
        if isinstance(alerts_chan, discord.abc.Messageable):
            await alerts_chan.send(
                f"⚠️ **Low Stock Alert!** {product} only has {total_stock} keys left!"
            )

    confirm_desc = (f"**Success {CONFIG['EMOJIS']['check']}**\n"
                    f"**User {CONFIG['EMOJIS']['user']}** {user.mention}\n"
                    f"**Product {CONFIG['EMOJIS']['key']}** {product}\n"
                    f"**Duration {CONFIG['EMOJIS']['duration']}** {duration}\n"
                    f"**DM Status** {dm_status}")
    confirm_embed = create_styled_embed(
        "Hidden Services | Key Successfully Sent", confirm_desc)
    await interaction.followup.send(embed=confirm_embed)


@bot.tree.command(name="clearstock",
                  description="Clear all keys of a specific duration")
@app_commands.describe(product="Select product", duration="Select duration")
@app_commands.choices(
    product=[app_commands.Choice(name=p, value=p) for p in CONFIG["PRODUCTS"]],
    duration=[
        app_commands.Choice(name=d, value=d) for d in CONFIG["DURATIONS"]
    ])
@is_authorized()
async def clearstock(interaction: discord.Interaction, product: str,
                     duration: str):
    if product in db["stock"] and isinstance(
            db["stock"][product], dict) and duration in db["stock"][product]:
        count = len(db["stock"][product][duration])
        db["stock"][product][duration] = []
        save_db(db)
        desc = f"Cleared **{count}** keys from **{product}** ({duration})"
        embed = create_styled_embed(
            f"{CONFIG['EMOJIS']['check']} Stock Cleared", desc)
        await interaction.response.send_message(embed=embed, ephemeral=True)
    else:
        await interaction.response.send_message(
            f"{CONFIG['EMOJIS']['cross']} No keys found for **{product}** ({duration})",
            ephemeral=True)


@bot.tree.command(name="logs", description="View recent key delivery logs")
@is_authorized()
async def logs(interaction: discord.Interaction):
    recent = db["sent_keys"][-10:]
    if not recent:
        await interaction.response.send_message("No logs found.",
                                                ephemeral=True)
        return

    log_list = []
    for log in reversed(recent):
        log_list.append(
            f"• {log['product']} ({log['duration']}) -> <@{log['user_id']}> by <@{log['sent_by']}>"
        )
    desc = "\n".join(log_list)

    embed = create_styled_embed(
        f"{CONFIG['EMOJIS']['history']} Recent Delivery Logs", desc)
    await interaction.response.send_message(embed=embed, ephemeral=True)


@bot.tree.command(name="userhistory",
                  description="Check key history for a specific user")
@app_commands.describe(user="User to check")
@is_authorized()
async def userhistory(interaction: discord.Interaction, user: discord.User):
    history = [log for log in db["sent_keys"] if log["user_id"] == user.id]
    if not history:
        await interaction.response.send_message(
            f"No history for {user.mention}.", ephemeral=True)
        return

    hist_list = [
        f"• {h['product']} ({h['duration']}) on {h['timestamp'][:10]}"
        for h in history[-15:]
    ]
    desc = "\n".join(hist_list)
    embed = create_styled_embed(
        f"{CONFIG['EMOJIS']['user']} History for {user.name}", desc)
    await interaction.response.send_message(embed=embed, ephemeral=True)


@bot.event
async def on_app_command_error(interaction: discord.Interaction,
                               error: app_commands.AppCommandError):
    if isinstance(error, app_commands.CheckFailure):
        if not interaction.response.is_done():
            user_id = interaction.user.id
            await interaction.response.send_message(
                f"{CONFIG['EMOJIS']['cross']} **Authorization Failed!**\nYour ID: `{user_id}` is not in the authorized list.",
                ephemeral=True)
    else:
        print(f"Error in command: {error}")


if __name__ == "__main__":
    if TOKEN: bot.run(TOKEN)
